<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover"/>
  <title>芽ばえ計測 Webアプリ（手動校正＋ズーム＋DPR対応｜試作5）</title>
  <style>
    :root{--bg:#0b1020;--panel:#121728;--ink:#eaf1ff;--accent:#3a64ff}
    html,body{height:100%;margin:0;background:var(--bg);color:var(--ink);font-family:-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, "Noto Sans JP"}
    header{position:sticky;top:0;z-index:10;background:#121728;border-bottom:1px solid #223}
    .toolbar{display:flex;flex-wrap:wrap;gap:8px;padding:10px}
    .toolbar button{padding:8px 12px;border-radius:10px;border:1px solid #334;background:#16203a;color:var(--ink);font-size:16px}
    .toolbar button.primary{background:var(--accent);border-color:#2f49cc;color:#fff}
    .toolbar button:disabled{opacity:.5}
    .panel{display:grid;grid-template-columns:1fr 320px;gap:10px;height:calc(100vh - 60px);padding:10px}
    .stage{background:#0d1426;border:1px solid #223;border-radius:12px;position:relative;overflow:hidden}
    canvas{width:100%;height:100%;display:block;touch-action:none}
    .side{background:#0d1426;border:1px solid #223;border-radius:12px;padding:10px;overflow:auto}
    .metric{font-variant-numeric:tabular-nums}
    .dot{width:14px;height:14px;border-radius:3px;border:1px solid #222;display:inline-block;vertical-align:middle}
    .toast{position:fixed;left:50%;bottom:16px;transform:translateX(-50%);background:rgba(15,20,40,.9);border:1px solid #2a3d9a;border-radius:10px;padding:8px 12px;color:#eaf1ff;z-index:9999;font-size:14px;pointer-events:none}
  </style>
</head>
<body>
<header>
  <div class="toolbar">
    <button id="btnChoose" class="primary" type="button">➀画像を選択</button>
    <input id="fileInput" type="file" accept="image/*" style="display:none"/>
    <button id="btnFit" type="button" disabled>全体表示</button>
    <button id="btnZoomIn" type="button" disabled>拡大＋</button>
    <button id="btnZoomOut" type="button" disabled>縮小－</button>
    <button id="btnZoom100" type="button" disabled>100%</button>
    <button id="btnManual" type="button" disabled>➁手動校正</button>
    <button id="btnCalibDone" type="button" disabled>③校正確定</button>
    <button id="btnReset" type="button" disabled>校正リセット</button>
    <button id="btnDraw" type="button" disabled>④胚軸をなぞる</button>
    <button id="btnClear" type="button" disabled>クリア</button>
    <button id="btnPick" type="button" disabled>⑤色(RGB値)を取得</button>
  </div>
</header>
<main class="panel">
  <div class="stage"><canvas id="canvas"></canvas></div>
  <aside class="side">
    <h3>結果</h3>
    <div>胚軸長: <span class="metric" id="lenOut">—</span>
      <select id="unitSel"><option value="mm">mm</option><option value="cm">cm</option></select>
    </div>
    <div>色RGB: <span class="metric" id="rgbOut">—</span> <span id="swatch" class="dot"></span></div>
    <div>スケール: <span id="scaleBadge">未設定</span></div>
    <hr>
    <ol>
      <li>画像を選択 → <b>手動校正</b>（交点を2点以上・直線上に順にタップ）→ <b>校正確定</b></li>
      <li>ピンチ：拡大縮小、2本指ドラッグ：平行移動（どのモードでも有効）</li>
      <li>胚軸をなぞる（1本の連続なぞり）／色取得 → 子葉をタップ</li>
      <li>校正リセットでやり直し</li>
    </ol>
  </aside>
</main>
<div id="toast" class="toast" style="display:none"></div>
<script>
// ====== Utilities ======
const $ = id => document.getElementById(id);
const ui = {
  choose: $('btnChoose'), file: $('fileInput'),
  fit: $('btnFit'), zoomIn: $('btnZoomIn'), zoomOut: $('btnZoomOut'), zoom100: $('btnZoom100'),
  manual: $('btnManual'), calibDone: $('btnCalibDone'), reset: $('btnReset'),
  draw: $('btnDraw'), undo: $('btnUndo'), clear: $('btnClear'), pick: $('btnPick'),
  len: $('lenOut'), rgb: $('rgbOut'), sw: $('swatch'), unit: $('unitSel'), scale: $('scaleBadge'),
  toast: $('toast')
};
const cvs = $('canvas');
const ctx = cvs.getContext('2d', { willReadFrequently: true });

// ====== State ======
let bmp = null;           // ImageBitmap
let pxPerCm = null;       // calibration
let view = { zoom: 1, ox: 0, oy: 0 }; const ZMIN=0.2, ZMAX=12;
let mode = 'idle';        // 'idle' | 'calib' | 'draw' | 'pick'
let trace = [];           // hypocotyl polyline
let calibPts = [];        // calibration points
const MIN_SEG_IMG = 2;    // smoothing params
const SMOOTH_ALPHA = 0.3;

// ====== DPR-safe canvas ======
function setCanvasSize(){
  const rect = cvs.parentElement.getBoundingClientRect();
  const dpr = window.devicePixelRatio || 1;
  cvs.style.width = rect.width + 'px';
  cvs.style.height = rect.height + 'px';
  cvs.width = Math.max(1, Math.floor(rect.width * dpr));
  cvs.height= Math.max(1, Math.floor(rect.height* dpr));
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
}
function fitToScreen(){ if(!bmp) return; setCanvasSize(); const rect=cvs.getBoundingClientRect(); view.zoom=Math.min(rect.width/bmp.width, rect.height/bmp.height); view.ox=(rect.width - bmp.width*view.zoom)/2; view.oy=(rect.height - bmp.height*view.zoom)/2; }
function pointerPos(e){ const r=cvs.getBoundingClientRect(); return { x:e.clientX - r.left, y:e.clientY - r.top }; }

// ====== View helpers ======
function clampZoom(z){ return Math.min(ZMAX, Math.max(ZMIN, z)); }
function setZoom(newZ, cx, cy){ if(!bmp) return; const z=clampZoom(newZ); const ix=(cx - view.ox)/view.zoom; const iy=(cy - view.oy)/view.zoom; view.ox = cx - ix*z; view.oy = cy - iy*z; view.zoom=z; redraw(); }
function zoomAt(f, cx, cy){ setZoom(view.zoom*f, cx, cy); }

// ====== Coord transforms ======
function viewToImage(vx,vy){ return { x:(vx-view.ox)/view.zoom, y:(vy-view.oy)/view.zoom }; }
function imageToView(ix,iy){ return { x: ix*view.zoom + view.ox, y: iy*view.zoom + view.oy }; }

// ====== Rendering ======
function redraw(){ const rect=cvs.getBoundingClientRect(); ctx.clearRect(0,0,rect.width,rect.height); if(!bmp) return;
  ctx.drawImage(bmp, view.ox, view.oy, bmp.width*view.zoom, bmp.height*view.zoom);
  if(trace.length){ ctx.lineWidth=4; ctx.strokeStyle='#ff1493'; ctx.lineJoin='round'; ctx.lineCap='round'; ctx.beginPath(); ctx.moveTo(trace[0].vx,trace[0].vy); for(let i=1;i<trace.length;i++) ctx.lineTo(trace[i].vx,trace[i].vy); ctx.stroke(); drawLengthLabel(); }
  if(calibPts.length){ ctx.strokeStyle='#ffd166'; ctx.lineWidth=2; ctx.setLineDash([6,4]); ctx.beginPath(); ctx.moveTo(calibPts[0].vx,calibPts[0].vy); for(let i=1;i<calibPts.length;i++) ctx.lineTo(calibPts[i].vx, calibPts[i].vy); ctx.stroke(); ctx.setLineDash([]); ctx.fillStyle='#ffd166'; calibPts.forEach(p=>{ ctx.beginPath(); ctx.arc(p.vx,p.vy,6,0,Math.PI*2); ctx.fill(); }); }
}
function drawLengthLabel(){ if(trace.length<2||!pxPerCm) return; const rect=cvs.getBoundingClientRect(); const end=trace[trace.length-1]; const text=ui.len.textContent; ctx.save(); ctx.font='14px -apple-system, Segoe UI, Roboto, Helvetica, Arial'; const pad=6, h=22; const w=Math.ceil(ctx.measureText(text).width)+pad*2; let x=end.vx+8, y=end.vy-h-8; if(x+w>rect.width) x=rect.width-w-8; if(y<8) y=end.vy+8; ctx.fillStyle='rgba(10,14,28,0.85)'; roundRect(ctx,x,y,w,h,8); ctx.fill(); ctx.strokeStyle='rgba(80,120,255,0.6)'; ctx.lineWidth=1; roundRect(ctx,x,y,w,h,8); ctx.stroke(); ctx.fillStyle='#eaf1ff'; ctx.fillText(text, x+pad, y+h-7); ctx.restore(); }
function roundRect(ctx,x,y,w,h,r){ ctx.beginPath(); ctx.moveTo(x+r,y); ctx.arcTo(x+w,y,x+w,y+h,r); ctx.arcTo(x+w,y+h,x,y+h,r); ctx.arcTo(x,y+h,x,y,r); ctx.arcTo(x,y,x+w,y,r); ctx.closePath(); }

// ====== UI wiring ======
function updateUI(){ const has=!!bmp; ui.fit.disabled=!has; ui.zoomIn.disabled=!has; ui.zoomOut.disabled=!has; ui.zoom100.disabled=!has; ui.manual.disabled=!has; ui.reset.disabled=!has; ui.draw.disabled=!has||!pxPerCm; ui.clear.disabled=!has; ui.pick.disabled=!has; ui.calibDone.disabled=!(mode==='calib' && calibPts.length>=2); }
ui.choose.onclick = () => ui.file.click();
ui.file.onchange = async () => { try {
  const f = ui.file.files && ui.file.files[0]; if(!f){ toast('ファイルが選択されませんでした'); return; }
  const url = URL.createObjectURL(f);
  const img = new Image(); img.decoding = 'sync';
  await new Promise(res => { img.onload = res; img.src = url; });
  if(bmp && bmp.close) try{ bmp.close(); }catch{}
  bmp = await createImageBitmap(img);
  URL.revokeObjectURL(url);
  // reset state
  pxPerCm=null; trace=[]; calibPts=[]; ui.len.textContent='—'; ui.rgb.textContent='—'; ui.sw.style.background='transparent'; ui.scale.textContent='未設定'; mode='idle';
  fitToScreen(); redraw(); updateUI(); toast('画像を読み込みました');
} catch(err){ console.error(err); toast('画像の読み込みでエラー: '+err.message); } };

// ドラッグ&ドロップ対応（PC向け）
const stage = cvs.parentElement;
stage.addEventListener('dragover', e=>{ e.preventDefault(); });
stage.addEventListener('drop', async e=>{ e.preventDefault(); if(!e.dataTransfer.files?.length) return; ui.file.files = e.dataTransfer.files; ui.file.dispatchEvent(new Event('change')); });

ui.fit.onclick   = ()=>{ fitToScreen(); redraw(); };
ui.zoomIn.onclick= ()=>{ const r=cvs.getBoundingClientRect(); zoomAt(1.2, r.width/2, r.height/2); };
ui.zoomOut.onclick=()=>{ const r=cvs.getBoundingClientRect(); zoomAt(1/1.2, r.width/2, r.height/2); };
ui.zoom100.onclick=()=>{ const r=cvs.getBoundingClientRect(); setZoom(1, r.width/2, r.height/2); };
ui.manual.onclick=()=>{ mode='calib'; calibPts=[]; ui.scale.textContent='交点を2点以上タップ（同一直線上推奨）→「校正確定」'; updateUI(); };
ui.calibDone.onclick=()=> finalizeCalibration();
ui.reset.onclick = ()=>{ pxPerCm=null; trace=[]; calibPts=[]; ui.len.textContent='—'; ui.rgb.textContent='—'; ui.sw.style.background='transparent'; ui.scale.textContent='未設定'; mode='idle'; fitToScreen(); redraw(); updateUI(); };
ui.draw.onclick  = ()=>{ if(!pxPerCm) return; trace=[]; mode='draw'; toast('胚軸をなぞってください（1本の連続なぞり）'); updateUI(); };
ui.clear.onclick = ()=>{ if(trace.length){ trace=[]; lengthOut(); redraw(); } };
ui.pick.onclick  = ()=>{ mode='pick'; toast('子葉の色をタップ'); };
ui.unit.onchange = ()=> lengthOut();

// ====== Pointer interactions ======
let isDown=false; const active=new Map(); let gesture=null;
function onPointerDown(e){ if(!bmp) { ui.file.click(); return; } const p=pointerPos(e); cvs.setPointerCapture(e.pointerId); active.set(e.pointerId,p); if(active.size===1){ isDown=true; if(mode==='draw'){ pushTrace(p); lengthOut(); redraw(); } } }
function onPointerMove(e){ if(!bmp) return; const p=pointerPos(e); const prev=active.get(e.pointerId); active.set(e.pointerId,p);
  if(active.size>=2){ const pts=[...active.values()]; const [p1,p2]=pts; const centerNow={x:(p1.x+p2.x)/2, y:(p1.y+p2.y)/2}; const distNow=Math.hypot(p1.x-p2.x, p1.y-p2.y); if(!gesture){ gesture={center:centerNow, dist:distNow}; return; } const scale=distNow/gesture.dist; zoomAt(scale, gesture.center.x, gesture.center.y); const dx=centerNow.x-gesture.center.x, dy=centerNow.y-gesture.center.y; view.ox+=dx; view.oy+=dy; redraw(); gesture={center:centerNow, dist:distNow}; isDown=false; }
  else if(isDown && mode==='draw'){ pushTrace(p); lengthOut(); redraw(); } }
function onPointerUp(e){ active.delete(e.pointerId); if(active.size<2) gesture=null; if(active.size===0) isDown=false; const p=pointerPos(e); if(mode==='pick' && !isDown) pickColor(p); if(mode==='calib' && !isDown) pickCalib(p); }

cvs.addEventListener('pointerdown', onPointerDown);
cvs.addEventListener('pointermove', onPointerMove);
cvs.addEventListener('pointerup',   onPointerUp);

// Wheel / trackpad zoom
cvs.addEventListener('wheel', e=>{ if(!bmp) return; e.preventDefault(); const p=pointerPos(e); const f=(e.deltaY<0)?1.1:1/1.1; zoomAt(f, p.x, p.y); }, {passive:false});

// Double-tap toggle
let lastTap=0; cvs.addEventListener('pointerdown', e=>{ const now=Date.now(); if(now-lastTap<300){ const r=cvs.getBoundingClientRect(); const fitZ=Math.min(r.width/bmp.width, r.height/bmp.height); if(view.zoom>fitZ+0.01) fitToScreen(); else setZoom(1, pointerPos(e).x, pointerPos(e).y); } lastTap=now; }, {capture:true});

// ====== Core ops ======
function pushTrace(p){ const q=viewToImage(p.x,p.y); if(trace.length){ const prev=trace[trace.length-1]; const d=Math.hypot(q.x-prev.ix, q.y-prev.iy); if(d<MIN_SEG_IMG) return; q.x=prev.ix*(1-SMOOTH_ALPHA)+q.x*SMOOTH_ALPHA; q.y=prev.iy*(1-SMOOTH_ALPHA)+q.y*SMOOTH_ALPHA; } trace.push({vx:p.x,vy:p.y, ix:q.x,iy:q.y}); }
function lengthOut(){ if(trace.length<2||!pxPerCm){ ui.len.textContent='—'; return; } let px=0; for(let i=1;i<trace.length;i++){ const a=trace[i-1], b=trace[i]; px += Math.hypot(b.ix-a.ix, b.iy-a.iy); } const cm=px/pxPerCm; const v=(ui.unit.value==='mm')?cm*10:cm; ui.len.textContent=v.toFixed(2)+' '+ui.unit.value; }
function pickColor(p){ const q=viewToImage(p.x,p.y); const off=document.createElement('canvas'); off.width=bmp.width; off.height=bmp.height; const o=off.getContext('2d'); o.drawImage(bmp,0,0); const r=5; const x=Math.max(0,Math.floor(q.x-r)), y=Math.max(0,Math.floor(q.y-r)); const w=Math.min(off.width-x, r*2), h=Math.min(off.height-y, r*2); const d=o.getImageData(x,y,w,h).data; let R=0,G=0,B=0,n=0; for(let j=0;j<h;j++){ for(let i=0;i<w;i++){ const dx=i-r, dy=j-r; if(dx*dx+dy*dy>r*r) continue; const k=(j*w+i)*4; R+=d[k]; G+=d[k+1]; B+=d[k+2]; n++; } } const rr=Math.round(R/n), gg=Math.round(G/n), bb=Math.round(B/n); ui.rgb.textContent=`(${rr}, ${gg}, ${bb})`; ui.sw.style.background=`rgb(${rr},${gg},${bb})`; }
function pickCalib(p){ const q=viewToImage(p.x,p.y); calibPts.push({vx:p.x,vy:p.y, ix:q.x,iy:q.y}); if(calibPts.length>=2){ let sum=0; for(let i=1;i<calibPts.length;i++){ const a=calibPts[i-1], b=calibPts[i]; sum += Math.hypot(b.ix-a.ix, b.iy-a.iy); } const seg=calibPts.length-1; const preview=sum/seg; ui.scale.textContent=`暫定: ${preview.toFixed(2)} px/cm（${seg}区間）`; } updateUI(); redraw(); }
function finalizeCalibration(){ if(calibPts.length<2) return; let sum=0; for(let i=1;i<calibPts.length;i++){ const a=calibPts[i-1], b=calibPts[i]; sum += Math.hypot(b.ix-a.ix, b.iy-a.iy); } const seg=calibPts.length-1; pxPerCm=sum/seg; ui.scale.textContent=`${pxPerCm.toFixed(2)} px/cm（${seg}区間平均）`; mode='idle'; calibPts=[]; updateUI(); redraw(); toast('平均校正を適用しました'); }

// ====== Toast ======
let toastTimer=null; function toast(msg){ ui.toast.textContent=msg; ui.toast.style.display='block'; clearTimeout(toastTimer); toastTimer=setTimeout(()=>{ ui.toast.style.display='none'; }, 1800); }

// init
setCanvasSize();
window.addEventListener('resize', ()=>{ setCanvasSize(); redraw(); });
</script>
</body>
</html>
